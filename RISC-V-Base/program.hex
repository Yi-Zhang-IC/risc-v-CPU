addi a4, zero, 1 (the starting random number used in ifsr)
// trigger loop
addi a1, zero, trigger
addi t0, zero, 1
bne a1, t0, trigger loop (when trigger is 1, go to next step)
addi a2, zero, 28       (count 255 cycle to tick 1 second)
addi t1, zero, 8
addi a3, zero, 1     (add 1 in each cycle of lighting, totally 8 cycle)
addi a0, zero, 1     (a0 for output, start from lighting the first light)
jal  rs, counter loop     (reg contains return address)
addi a3, a3, 1
slli a0, a0, 1          
addi a0, a0, 1       (shift 1 and add 1 to light up the next light)
bne  a3, t1, -4      (to test whether it counts 8 loops. For each loop, one lights goes on)

// when all lights are on, go next step to generate an random number
//ifsr loop, to generate a random number
andi a6, 1000, a4
andi a7, 0100, a4
sill a4, a4, 1  (shif )
srli a6, a6, 3  (shift x4 to the left most)
srli a7, a7, 2  (shift x3 to the left most)
xor a6, a6, a7  (x3 xor x4)
add a4, a4, a6  (a4 is the new random number for delaying)

// when random number is generated, start the delay loop
addi a3, zero, 1       
jal  rs, counter loop       (reg contains return address)
addi a3, a3, 1
bne  a3, a4, -2    (count a4 delay loops then go next step to close all lights)
addi a0, zero, 0   (give output a0 the value zero so close all light)

//the counter loop that counts one second (the subroutine using JAL)
addi a5, zero, 0
addi a5, a5, 1
bne  a5, a2, -1 (go to next step when counts 28(a2) cycles. Estimating count 28 cycle spending 1 second)
jalr rs, 0(rs)       (reg contains return address rs)